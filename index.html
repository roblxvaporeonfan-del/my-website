<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Block Sandbox</title>
    <!-- Tailwind CSS CDN for styling the overlay --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font --><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <!-- Three.js CDN for 3D rendering --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Cannon.js CDN for physics --><script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- Tone.js for sound effects (synthesized audio) --><script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }

        /* Keyframe animation for the death screen pulse effect */
        @keyframes pulse-death {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.05); opacity: 0.9; }
        }

        /* Base style for all floating messages and menus */
        .ui-box {
            position: absolute;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 0.75rem;
            text-align: center;
            font-weight: bold;
            z-index: 200;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        
        /* Full-screen overlays */
        .full-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: white;
            padding: 20px;
        }

        /* Menu Card Styling */
        .menu-card {
            background-color: #1f2937;
            padding: 40px;
            border-radius: 1.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            max-width: 90%;
            width: 400px;
        }
        
        .menu-card h1 {
            font-size: 2.5rem;
            font-weight: 900;
            color: #facc15; /* Yellow/Gold for character block */
            margin-bottom: 20px;
        }

        .menu-button {
            width: 100%;
            padding: 15px 0;
            margin-top: 15px;
            font-size: 1.25rem;
            font-weight: 700;
            border-radius: 0.75rem;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .primary-button {
            background-color: #10b981; /* Green */
            color: #1f2937;
            border: 3px solid #059669;
        }
        .primary-button:hover {
            background-color: #059669;
            color: white;
        }

        .secondary-button {
            background-color: #3b82f6; /* Blue */
            color: white;
            border: 3px solid #2563eb;
        }
        .secondary-button:hover {
            background-color: #2563eb;
            color: #f3f4f6;
        }

        /* Death Message Box */
        .message-box {
            top: 50%;
            padding: 30px 60px;
            background-color: rgba(220, 38, 38, 0.9); /* Deep Red */
            color: white;
            font-size: 2rem;
            border: 4px solid #b91c1c;
            animation: pulse-death 1s infinite alternate; 
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* How To Play Text Formatting */
        #instructions-content {
            text-align: left;
            padding: 20px;
            max-width: 600px;
            overflow-y: auto;
            max-height: 80vh;
        }
        #instructions-content h2 {
            font-size: 1.75rem;
            font-weight: 700;
            color: #facc15;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        #instructions-content p {
            margin-bottom: 15px;
            font-size: 1.1rem;
            line-height: 1.6;
        }
        #instructions-content ul {
            list-style-type: none;
            padding-left: 0;
        }
        #instructions-content ul li {
            background-color: #374151;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 0.5rem;
        }
        #instructions-content ul li strong {
            color: #38bdf8; /* Blue highlight */
        }
        
        /* Crosshair for PC mode */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border-radius: 50%;
            border: 1px solid white;
            background-color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: difference;
            display: none; 
        }
        
        /* --- Mobile Controls Styling --- */
        .action-button-large {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(16, 185, 129, 0.7); 
            color: white;
            border-radius: 50%; 
            width: 80px;
            height: 80px;
            font-size: 1rem;
            font-weight: 900;
            user-select: none;
            cursor: pointer;
            border: 3px solid #059669;
            touch-action: none;
            transition: all 0.1s;
        }
        .action-button-large:active, .action-button-large.active {
            background-color: rgba(5, 150, 105, 0.9);
            transform: scale(0.95);
        }
        .action-button-small {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(239, 68, 68, 0.7); 
            color: white;
            border-radius: 12px;
            width: 100px;
            height: 40px;
            font-size: 0.75rem;
            font-weight: 700;
            user-select: none;
            cursor: pointer;
            border: 2px solid #dc2626;
            touch-action: none;
            transition: all 0.1s;
        }
        .action-button-small:active, .action-button-small.active {
             background-color: rgba(220, 38, 38, 0.9);
        }
        #touch-look-area {
            /* This area handles the camera movement via drag */
            background-color: transparent; 
        }

        /* --- Joystick Specific Styling --- */
        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background-color: rgba(31, 41, 55, 0.5); /* Base bg-gray-800 */
            border-radius: 50%;
            border: 3px solid rgba(107, 114, 128, 0.7); /* border-gray-500 */
            pointer-events: auto;
            touch-action: none;
            display: none; /* Only shown in mobile mode */
            z-index: 1000;
        }

        #joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background-color: rgba(59, 130, 246, 0.8); /* Handle bg-blue-500 */
            border-radius: 50%;
            border: 3px solid rgba(37, 99, 235, 0.8); /* border-blue-700 */
            cursor: grab;
            touch-action: none;
        }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- Crosshair (PC ONLY) -->
        <div id="crosshair"></div>
        
        <!-- Loading Overlay -->
        <div id="loading-overlay" class="full-overlay bg-gray-900">
            <div class="menu-card bg-gray-800">
                <h1 class="text-white text-3xl font-black mb-4">Loading 3D Block Sandbox...</h1>
                <p class="text-gray-400 mt-4">Initializing environment and physics.</p>
                <!-- Tailwind Spinner -->
                <div class="mt-8 flex justify-center">
                    <svg class="animate-spin h-8 w-8 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </div>
            </div>
        </div>
        
        <!-- Device Selection Overlay (NEW STEP) -->
        <div id="device-select-overlay" class="full-overlay">
            <div class="menu-card">
                <h1>Select Control Mode</h1>
                <p class="text-gray-300 mb-6">How will you be playing today?</p>
                <button id="select-pc" class="menu-button primary-button">
                    PC / Keyboard & Mouse
                </button>
                <button id="select-mobile" class="menu-button secondary-button">
                    Mobile / Touchscreen
                </button>
            </div>
        </div>

        <!-- Main Menu Overlay -->
        <div id="main-menu-overlay" class="full-overlay" style="display: none;">
            <div class="menu-card">
                <h1>Block Sandbox World</h1>
                <p id="mode-confirmation" class="text-gray-300 mb-6"></p>
                <button id="play-button" class="menu-button primary-button">
                    Start Exploring
                </button>
                <button id="instructions-button" class="menu-button secondary-button">
                    Controls
                </button>
            </div>
        </div>

        <!-- Instructions Overlay -->
        <div id="instructions-overlay" class="full-overlay" style="display: none;">
            <div id="instructions-content" class="menu-card">
                <h1 style="text-align: center;">Controls</h1>
                <div id="control-list"></div>
                <button id="back-to-menu-button" class="menu-button secondary-button mt-4">
                    Back to Main Menu
                </button>
            </div>
        </div>

        <!-- Mobile Controls Overlay (Hidden by default, shown when isMobile is true) -->
        <div id="mobile-controls" style="display: none; position: fixed; bottom: 0; left: 0; width: 100%; height: 100%; z-index: 1000; pointer-events: none;">
            
            <!-- Virtual Joystick (Left) -->
            <div id="joystick-container">
                <div id="joystick-handle"></div>
            </div>
            
            <!-- Action/Jump Buttons (Right) -->
            <div class="fixed bottom-4 right-4 flex flex-col items-center space-y-4" style="pointer-events: auto;">
                <div id="jump-button-mobile" class="action-button-large" data-key="space" style="pointer-events: auto;">JUMP</div>
                <div id="respawn-button-mobile" class="action-button-small" data-key="e" style="pointer-events: auto;">RESPAWN (E)</div>
            </div>
            
            <!-- Touch Look Area (Full screen width for mobile, pointer-events: none initially) -->
            <div id="touch-look-area" class="fixed top-0 left-0 w-full h-full" style="pointer-events: auto;"></div>
        </div>


        <!-- Game UI Elements -->
        <!-- Death/Status Message Box -->
        <div id="message-box" class="message-box ui-box" style="display: none;">
            <span>VOIDED! Press E or use the RESPAWN button.</span>
        </div>
        
        <!-- Return to Menu Button (Fixed Position) -->
        <button id="return-to-menu-button" 
            class="fixed bottom-5 left-5 px-6 py-3 bg-indigo-600 text-white font-bold rounded-xl 
                   shadow-lg hover:bg-indigo-700 transition-all z-50"
            style="display: none;">
            Press L to Return to Menu
        </button>

    </div>

    <script>
        // --- Global Variables & Constants ---
        let scene, camera, renderer, world;
        let playerMesh, playerBody, startPosition;
        let playerMaterial, groundMaterial;

        const TIME_STEP = 1 / 60;
        const MOVEMENT_SPEED = 16;
        const JUMP_VELOCITY = 18;
        const CAMERA_DISTANCE = 15;
        const CAMERA_HEIGHT = 5;
        const MOUSE_SENSITIVITY = 0.0015; 
        const TOUCH_SENSITIVITY = 0.004;

        const keys = { w: false, a: false, s: false, d: false, space: false, e: false, l: false }; 
        let isPointerLocked = false;
        let playerYaw = 0;
        let isDead = false;
        let isGamePaused = true; 
        let isMobile = false; // Set by user selection

        // Joystick variables
        let joystickCenter = { x: 0, y: 0 };
        const joystickRadius = 60; // Half of the container size (120px)
        let joystickTouchIdentifier = null;

        // Block/Capsule dimensions
        const playerDimensions = { radius: 1, height: 2 }; 
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        
        // --- Tone.js Sound Variables & Functions ---
        let synth;
        let jumpSynth;
        let isAudioReady = false;

        async function initAudio() {
            if (isAudioReady) return; 
            try {
                await Tone.start();
                
                synth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.3 }
                }).toDestination();

                jumpSynth = new Tone.PluckSynth({
                    attackNoise: 1, dampening: 2000, resonance: 0.7,
                }).toDestination();
                
                isAudioReady = true;
            } catch (e) {
                console.error("Audio initialization failed:", e);
            }
        }

        function playJumpSound() {
            if (!isAudioReady) return;
            jumpSynth.triggerAttackRelease("C5", "8n"); 
        }

        function playRespawnSound() {
            if (!isAudioReady) return;
            synth.triggerAttackRelease("G4", "16n", Tone.now() + 0.005);
        }
        
        function playDeathSound() {
            if (!isAudioReady) return;
            synth.triggerAttackRelease("C3", "8n", Tone.now());
            synth.triggerAttackRelease("B2", "8n", Tone.now() + 0.1);
            synth.triggerAttackRelease("A#2", "8n", Tone.now() + 0.2);
        }

        function hexToColor(hex) {
            return parseInt(hex.replace('#', '0x'), 16);
        }

        function showMessage(message) {
            const box = document.getElementById('message-box');
            box.querySelector('span').textContent = message;
            box.style.display = 'block';
        }

        // --- Menu Logic & Initialization ---
        
        function setupMenuListeners() {
            // Device Selection
            document.getElementById('select-pc').addEventListener('click', () => setDeviceMode(false));
            document.getElementById('select-mobile').addEventListener('click', () => setDeviceMode(true));

            // Main Menu
            document.getElementById('play-button').addEventListener('click', startGame);
            document.getElementById('instructions-button').addEventListener('click', showInstructions);
            document.getElementById('back-to-menu-button').addEventListener('click', showMainMenu);
        }
        
        function setDeviceMode(isMobileMode) {
            isMobile = isMobileMode;
            document.getElementById('device-select-overlay').style.display = 'none';
            document.getElementById('main-menu-overlay').style.display = 'flex';
            
            const confirmationText = isMobile 
                ? "Mobile controls selected: Joystick + Touch Look."
                : "PC controls selected: WASD + Mouse Look.";
            document.getElementById('mode-confirmation').textContent = confirmationText;

            // Show/hide PC specific UI elements
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('return-to-menu-button').style.display = isMobile ? 'none' : 'block';
            document.getElementById('mobile-controls').style.display = isMobile ? 'block' : 'none';

            if (isMobile) {
                setupJoystickControls();
                setupMobileButtonControls();
                setupTouchLook();
            }
        }

        function startGame() {
            document.getElementById('main-menu-overlay').style.display = 'none';
            document.getElementById('instructions-overlay').style.display = 'none';
            isGamePaused = false;
            
            if (!isMobile) {
                // PC: Attempt to lock the pointer
                renderer.domElement.requestPointerLock();
                document.getElementById('crosshair').style.display = 'block';
            }
            
            initAudio();
        }

        function showInstructions() {
            document.getElementById('main-menu-overlay').style.display = 'none';
            document.getElementById('instructions-overlay').style.display = 'flex';
            updateInstructionsContent();
        }

        function updateInstructionsContent() {
            const container = document.getElementById('control-list');
            let content = '';

            if (isMobile) {
                content = `
                    <h2>Mobile Controls (Touch/Gesture)</h2>
                    <ul>
                        <li><strong>Virtual Joystick (Left):</strong> Controls movement (Forward/Back/Strafe)</li>
                        <li><strong>Right Side Drag:</strong> Look Around (Drag finger across the right side of the screen)</li>
                        <li><strong>JUMP Button:</strong> Jump</li>
                        <li><strong>RESPAWN Button:</strong> Respawn at center (if you fall off)</li>
                        <li><strong>Press L Key (optional):</strong> Return to Main Menu</li>
                    </ul>
                `;
            } else {
                content = `
                    <h2>Movement Controls (PC)</h2>
                    <ul>
                        <li><strong>W, A, S, D</strong>: Movement (Forward/Back/Strafe)</li>
                        <li><strong>Spacebar</strong>: Jump</li>
                        <li><strong>Mouse Movement</strong>: Look Around (Click the screen to start)</li>
                    </ul>

                    <h2>Game Actions (PC)</h2>
                    <ul>
                        <li><strong>E</strong>: Respawn at center (if you fall off)</li>
                        <li><strong>L</strong>: Return to Main Menu</li>
                    </ul>
                `;
            }
            container.innerHTML = content;
        }

        function showMainMenu() {
            // Hide all game-related UI elements
            document.getElementById('instructions-overlay').style.display = 'none';
            document.getElementById('message-box').style.display = 'none';
            document.getElementById('return-to-menu-button').style.display = 'none'; 
            document.getElementById('crosshair').style.display = 'none';

            // Show the device selection menu again, or the main menu if device is already set
            document.getElementById('device-select-overlay').style.display = 'flex';
            document.getElementById('main-menu-overlay').style.display = 'none';

            isGamePaused = true;
            isDead = false; 

            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }


        // --- Three.js & Cannon.js Initialization ---

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(hexToColor('#7cb9e8'));

            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; 
            directionalLight.shadow.mapSize.height = 2048;
            const d = 500; 
            directionalLight.shadow.camera.left = -d;
            directionalLight.shadow.camera.right = d;
            directionalLight.shadow.camera.top = d;
            directionalLight.shadow.camera.bottom = -d;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 1000; 
            scene.add(directionalLight);

            world = new CANNON.World();
            world.gravity.set(0, -30, 0);
            world.broadphase = new CANNON.NaiveBroadphase();

            playerMaterial = new CANNON.Material("playerMaterial");
            groundMaterial = new CANNON.Material("groundMaterial");
            
            const playerGroundContact = new CANNON.ContactMaterial(
                playerMaterial, groundMaterial, { friction: 0.0, restitution: 0 }
            );
            world.addContactMaterial(playerGroundContact);

            createPlayer(0, 5, 0);
            createMassivePlane();

            // Global Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // PC Mouse Look Setup (conditional)
            renderer.domElement.addEventListener('click', () => {
                if (!isGamePaused && !isMobile) { 
                    renderer.domElement.requestPointerLock();
                }
            });
            document.addEventListener('pointerlockchange', lockChangeAlert, false);
            document.addEventListener('mousemove', onMouseMove, false);
            
            setupMenuListeners(); 
            // Initialize joystick center for later use
            const container = document.getElementById('joystick-container');
            const rect = container.getBoundingClientRect();
            joystickCenter = { x: rect.left + joystickRadius, y: rect.top + joystickRadius };
        }

        function createPlayer(x, y, z) {
            startPosition = new CANNON.Vec3(x, y, z);
            const geometry = new THREE.CylinderGeometry(playerDimensions.radius, playerDimensions.radius, playerDimensions.height, 16);
            const material = new THREE.MeshStandardMaterial({ color: hexToColor('#facc15'), metalness: 0.1, roughness: 0.5 });
            playerMesh = new THREE.Mesh(geometry, material);
            playerMesh.position.set(x, y, z);
            playerMesh.castShadow = true;
            scene.add(playerMesh);

            const shape = new CANNON.Cylinder(playerDimensions.radius, playerDimensions.radius, playerDimensions.height, 16);
            playerBody = new CANNON.Body({
                mass: 5, position: startPosition, shape: shape, linearDamping: 0.1, 
                fixedRotation: true, material: playerMaterial 
            });

            const quat = new CANNON.Quaternion();
            quat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            playerBody.quaternion.mult(quat, playerBody.quaternion);

            world.addBody(playerBody);
        }
        
        function createMassivePlane() {
            const massiveSize = 1000;
            const geometry = new THREE.BoxGeometry(massiveSize, 1, massiveSize);
            const material = new THREE.MeshStandardMaterial({ color: hexToColor('#008000') });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, -0.5, 0);
            mesh.receiveShadow = true;
            mesh.userData.type = 'platform';
            scene.add(mesh);

            const shape = new CANNON.Box(new CANNON.Vec3(massiveSize / 2, 0.5, massiveSize / 2));
            const body = new CANNON.Body({ 
                mass: 0, 
                shape: shape, 
                position: new CANNON.Vec3(0, -0.5, 0),
                material: groundMaterial
            });
            world.addBody(body);
        }

        // --- Controls & Movement (PC KEYBOARD) ---

        function onKeyDown(event) {
            if (event.code === 'KeyL') {
                keys.l = true;
                if (!isGamePaused) { showMainMenu(); }
                return;
            }

            if (isDead && event.code !== 'KeyE') return;
            if (isGamePaused || isMobile) return;

            switch (event.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyA': keys.a = true; break; 
                case 'KeyS': keys.s = true; break;
                case 'KeyD': keys.d = true; break; 
                
                case 'KeyE': 
                    keys.e = true;
                    if (isDead) { respawn(); }
                    break;
                
                case 'Space': keys.space = true; break;
            }
        }

        function onKeyUp(event) {
            if (isGamePaused || isMobile) return; 

            switch (event.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyD': keys.d = false; break;
                case 'Space': keys.space = false; break;
                case 'KeyE': keys.e = false; break;
                case 'KeyL': keys.l = false; break; 
            }
        }

        function lockChangeAlert() {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
            document.getElementById('crosshair').style.display = isPointerLocked ? 'block' : 'none';
        }

        function onMouseMove(event) {
            if (isPointerLocked && !isGamePaused) {
                playerYaw -= event.movementX * MOUSE_SENSITIVITY;
                playerMesh.rotation.y = playerYaw;
            }
        }
        
        // --- Controls & Movement (MOBILE JOYSTICK & TOUCH) ---

        let touchLookIdentifier = null; // To track the touch that initiated look/drag

        function setupMobileButtonControls() {
            const jumpButton = document.getElementById('jump-button-mobile');
            const respawnButton = document.getElementById('respawn-button-mobile');

            // 1. Jump Button
            jumpButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!isGamePaused && !isDead) {
                    keys.space = true;
                    jumpButton.classList.add('active');
                }
            }, { passive: false });
            jumpButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.space = false;
                jumpButton.classList.remove('active');
            }, { passive: false });

            // 2. Respawn Button (Touch E)
            respawnButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (isDead) { 
                    respawn();
                    respawnButton.classList.add('active');
                }
            }, { passive: false });
            respawnButton.addEventListener('touchend', () => {
                 respawnButton.classList.remove('active');
            });
        }

        function setupJoystickControls() {
            const container = document.getElementById('joystick-container');
            const handle = document.getElementById('joystick-handle');
            
            const maxTravel = joystickRadius - (handle.offsetWidth / 2);

            function updateJoystick(x, y) {
                // Constrain the handle movement to the circle boundary
                const dx = x - joystickCenter.x;
                const dy = y - joystickCenter.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > maxTravel) {
                    const ratio = maxTravel / distance;
                    x = joystickCenter.x + dx * ratio;
                    y = joystickCenter.y + dy * ratio;
                    distance = maxTravel; 
                }
                
                // Update handle position (relative to container)
                const newX = x - container.getBoundingClientRect().left;
                const newY = y - container.getBoundingClientRect().top;
                handle.style.left = `${newX}px`;
                handle.style.top = `${newY}px`;
                handle.style.transform = 'translate(-50%, -50%)';

                // Calculate movement key states based on handle position
                if (!isGamePaused && !isDead) {
                    const normalizedX = (x - joystickCenter.x) / maxTravel; // Strafe control (-1 to 1)
                    const normalizedY = (y - joystickCenter.y) / maxTravel; // Forward/Back control (-1 to 1)

                    // Forward/Backward (W/S) - inverted Y due to screen coords
                    keys.w = normalizedY < -0.2;
                    keys.s = normalizedY > 0.2;
                    // Strafing (A/D)
                    keys.a = normalizedX < -0.2;
                    keys.d = normalizedX > 0.2;
                }
            }

            function resetJoystick() {
                handle.style.left = '50%';
                handle.style.top = '50%';
                handle.style.transform = 'translate(-50%, -50%)';
                keys.w = keys.a = keys.s = keys.d = false;
                joystickTouchIdentifier = null;
            }
            
            container.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                if (joystickTouchIdentifier === null && e.changedTouches.length > 0) {
                    joystickTouchIdentifier = e.changedTouches[0].identifier;
                    updateJoystick(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                }
            }, { passive: false });

            container.addEventListener('touchmove', (e) => {
                e.preventDefault(); 
                if (joystickTouchIdentifier !== null) {
                    let touch;
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === joystickTouchIdentifier) {
                            touch = e.changedTouches[i];
                            break;
                        }
                    }
                    if (touch) {
                        updateJoystick(touch.clientX, touch.clientY);
                    }
                }
            }, { passive: false });

            container.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchIdentifier) {
                        resetJoystick();
                        break;
                    }
                }
            });

            container.addEventListener('touchcancel', resetJoystick);
        }

        function setupTouchLook() {
            const touchLookArea = document.getElementById('touch-look-area');

            touchLookArea.addEventListener('touchstart', (e) => {
                if (isGamePaused || isDead) return;
                
                // Track the first touch that isn't already claimed by the joystick
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier !== joystickTouchIdentifier) {
                        touchLookIdentifier = e.changedTouches[i].identifier;
                        touchLookArea.lastX = e.changedTouches[i].clientX;
                        break; 
                    }
                }
            }, { passive: false });

            touchLookArea.addEventListener('touchmove', (e) => {
                e.preventDefault(); 
                if (isGamePaused || isDead || touchLookIdentifier === null) return;

                let touch;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchLookIdentifier) {
                        touch = e.changedTouches[i];
                        break;
                    }
                }

                if (touch) {
                    const deltaX = touch.clientX - (touchLookArea.lastX || touch.clientX);
                    
                    playerYaw -= deltaX * TOUCH_SENSITIVITY;
                    playerMesh.rotation.y = playerYaw;
                    
                    touchLookArea.lastX = touch.clientX;
                }
            }, { passive: false });

            touchLookArea.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchLookIdentifier) {
                        touchLookIdentifier = null;
                        touchLookArea.lastX = null;
                        break;
                    }
                }
            });
        }


        // --- Game Logic ---

        function isGrounded() {
            const playerPos = playerMesh.position.clone();
            const origin = new THREE.Vector3(playerPos.x, playerPos.y - playerDimensions.height / 2 + 0.1, playerPos.z); 
            raycaster.set(origin, downVector);
            raycaster.far = 0.2; 

            const platforms = scene.children.filter(c => c.isMesh && c.userData.type === 'platform');
            const intersects = raycaster.intersectObjects(platforms, false);
            return intersects.length > 0;
        }

        function handlePlayerMovement() {
            if (isDead || isGamePaused) return;

            const grounded = isGrounded();
            const yaw = playerYaw; 

            let currentVelocityY = playerBody.velocity.y;
            let targetVelocityX = 0;
            let targetVelocityZ = 0;

            const forwardX = Math.sin(yaw);
            const forwardZ = Math.cos(yaw);
            const rightX = Math.sin(yaw + Math.PI / 2);
            const rightZ = Math.cos(yaw + Math.PI / 2);

            // Calculate movement based on keys (set by PC input or joystick)
            if (keys.w) {
                targetVelocityX += forwardX * MOVEMENT_SPEED;
                targetVelocityZ += forwardZ * MOVEMENT_SPEED;
            }
            if (keys.s) {
                targetVelocityX -= forwardX * MOVEMENT_SPEED;
                targetVelocityZ -= forwardZ * MOVEMENT_SPEED;
            }
            if (keys.a) {
                targetVelocityX -= rightX * MOVEMENT_SPEED;
                targetVelocityZ -= rightZ * MOVEMENT_SPEED;
            }
            if (keys.d) {
                targetVelocityX += rightX * MOVEMENT_SPEED;
                targetVelocityZ += rightZ * MOVEMENT_SPEED;
            }
            
            playerBody.velocity.x = targetVelocityX;
            playerBody.velocity.z = targetVelocityZ;
            
            if (keys.space && grounded) { 
                currentVelocityY = JUMP_VELOCITY;
                playJumpSound();
            }
            
            playerBody.velocity.y = currentVelocityY;

            const isMoving = targetVelocityX !== 0 || targetVelocityZ !== 0;
            playerBody.linearDamping = isMoving ? 0.05 : 0.9;
        }

        function respawn() {
            if (!isDead) return;

            isDead = false;
            playerBody.velocity.set(0, 0, 0);
            playerBody.angularVelocity.set(0, 0, 0);
            playerBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), playerYaw);

            playerBody.position.copy(startPosition); 
            
            playerMesh.visible = true;
            document.getElementById('message-box').style.display = 'none';
            
            if (!isMobile) {
                document.getElementById('return-to-menu-button').style.display = 'block'; 
                renderer.domElement.requestPointerLock();
                document.getElementById('crosshair').style.display = 'block';
            }
            
            playRespawnSound();
        }

        function resetPlayer(reason) {
            playerBody.velocity.set(0, 0, 0);
            playerBody.angularVelocity.set(0, 0, 0);
            playerMesh.visible = false;
            
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }

            if (reason === 'Void') {
                isDead = true;
                showMessage("VOIDED! Press E or use the RESPAWN button.");
                playDeathSound();
            }
            
            document.getElementById('return-to-menu-button').style.display = 'none'; 
            document.getElementById('crosshair').style.display = 'none';
        }

        function checkVoid() {
            if (isDead || isGamePaused) return;

            if (playerMesh.position.y < -10) {
                resetPlayer('Void');
                return;
            }
        }

        // --- Rendering Loop & Utilities ---

        let clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            if (!isGamePaused) {
                const delta = clock.getDelta();

                if (!isDead) {
                    world.step(TIME_STEP, delta); 
                }

                handlePlayerMovement();
                
                playerMesh.position.copy(playerBody.position);
                
                checkVoid();
            }
            
            updateCamera();

            renderer.render(scene, camera);
        }

        function updateCamera() {
            const playerPos = playerMesh.position;

            if (!playerMesh) return; 

            const offsetX = CAMERA_DISTANCE * Math.sin(playerYaw);
            const offsetZ = CAMERA_DISTANCE * Math.cos(playerYaw);

            const targetCameraPos = new THREE.Vector3(
                playerPos.x - offsetX,
                playerPos.y + CAMERA_HEIGHT,
                playerPos.z - offsetZ
            );

            camera.position.lerp(targetCameraPos, 0.1);
            camera.lookAt(playerPos.x, playerPos.y + playerDimensions.height / 4, playerPos.z);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Recalculate joystick center on resize
            const container = document.getElementById('joystick-container');
            const rect = container.getBoundingClientRect();
            joystickCenter = { x: rect.left + joystickRadius, y: rect.top + joystickRadius };
        }

        // --- Initial Load Sequence ---

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('loading-overlay').style.display = 'none';
            init(); 
            animate();
            // Show the device selection first
            document.getElementById('device-select-overlay').style.display = 'flex'; 
        });

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Block Sandbox</title>
    <!-- Tailwind CSS CDN for styling the overlay --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font --><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <!-- Three.js CDN for 3D rendering --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Cannon.js CDN for physics --><script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- Tone.js for sound effects (synthesized audio) --><script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }

        /* Keyframe animation for the death screen pulse effect */
        @keyframes pulse-death {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.05); opacity: 0.9; }
        }

        /* Base style for all floating messages and menus */
        .ui-box {
            position: absolute;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 0.75rem;
            text-align: center;
            font-weight: bold;
            z-index: 200;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        
        /* Full-screen overlays */
        .full-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: white;
            padding: 20px;
        }

        /* Menu Card Styling */
        .menu-card {
            background-color: #1f2937;
            padding: 40px;
            border-radius: 1.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            max-width: 90%;
            width: 400px;
        }
        
        .menu-card h1 {
            font-size: 2.5rem;
            font-weight: 900;
            color: #facc15; /* Yellow/Gold for character block */
            margin-bottom: 20px;
        }

        .menu-button {
            width: 100%;
            padding: 15px 0;
            margin-top: 15px;
            font-size: 1.25rem;
            font-weight: 700;
            border-radius: 0.75rem;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .primary-button {
            background-color: #10b981; /* Green */
            color: #1f2937;
            border: 3px solid #059669;
        }
        .primary-button:hover {
            background-color: #059669;
            color: white;
        }

        .secondary-button {
            background-color: #3b82f6; /* Blue */
            color: white;
            border: 3px solid #2563eb;
        }
        .secondary-button:hover {
            background-color: #2563eb;
            color: #f3f4f6;
        }

        /* Death Message Box */
        .message-box {
            top: 50%;
            padding: 30px 60px;
            background-color: rgba(220, 38, 38, 0.9); /* Deep Red */
            color: white;
            font-size: 2rem;
            border: 4px solid #b91c1c;
            animation: pulse-death 1s infinite alternate; 
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* How To Play Text Formatting */
        #instructions-content {
            text-align: left;
            padding: 20px;
            max-width: 600px;
            overflow-y: auto;
            max-height: 80vh;
        }
        #instructions-content h2 {
            font-size: 1.75rem;
            font-weight: 700;
            color: #facc15;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        #instructions-content p {
            margin-bottom: 15px;
            font-size: 1.1rem;
            line-height: 1.6;
        }
        #instructions-content ul {
            list-style-type: none;
            padding-left: 0;
        }
        #instructions-content ul li {
            background-color: #374151;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 0.5rem;
        }
        #instructions-content ul li strong {
            color: #38bdf8; /* Blue highlight */
        }
        
        /* Crosshair for PC mode */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border-radius: 50%;
            border: 1px solid white;
            background-color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: difference;
            display: none; 
        }
        
        /* --- Mobile Controls Styling --- */
        .action-button-large {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(16, 185, 129, 0.7); 
            color: white;
            border-radius: 50%; 
            width: 80px;
            height: 80px;
            font-size: 1rem;
            font-weight: 900;
            user-select: none;
            cursor: pointer;
            border: 3px solid #059669;
            touch-action: none;
            transition: all 0.1s;
        }
        .action-button-large:active, .action-button-large.active {
            background-color: rgba(5, 150, 105, 0.9);
            transform: scale(0.95);
        }
        .action-button-small {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(239, 68, 68, 0.7); 
            color: white;
            border-radius: 12px;
            width: 100px;
            height: 40px;
            font-size: 0.75rem;
            font-weight: 700;
            user-select: none;
            cursor: pointer;
            border: 2px solid #dc2626;
            touch-action: none;
            transition: all 0.1s;
        }
        .action-button-small:active, .action-button-small.active {
             background-color: rgba(220, 38, 38, 0.9);
        }
        #touch-look-area {
            /* This area handles the camera movement via drag */
            background-color: transparent; 
        }

        /* --- Joystick Specific Styling --- */
        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background-color: rgba(31, 41, 55, 0.5); /* Base bg-gray-800 */
            border-radius: 50%;
            border: 3px solid rgba(107, 114, 128, 0.7); /* border-gray-500 */
            pointer-events: auto;
            touch-action: none;
            display: block; 
            z-index: 1000;
        }

        #joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background-color: rgba(59, 130, 246, 0.8); /* Handle bg-blue-500 */
            border-radius: 50%;
            border: 3px solid rgba(37, 99, 235, 0.8); /* border-blue-700 */
            cursor: grab;
            touch-action: none;
        }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- Crosshair (PC ONLY) -->
        <div id="crosshair"></div>
        
        <!-- Loading Overlay -->
        <div id="loading-overlay" class="full-overlay bg-gray-900">
            <div class="menu-card bg-gray-800">
                <h1 class="text-white text-3xl font-black mb-4">Loading 3D Block Sandbox...</h1>
                <p class="text-gray-400 mt-4">Initializing environment and physics.</p>
                <!-- Tailwind Spinner -->
                <div class="mt-8 flex justify-center">
                    <svg class="animate-spin h-8 w-8 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </div>
            </div>
        </div>
        
        <!-- Device Selection Overlay -->
        <div id="device-select-overlay" class="full-overlay">
            <div class="menu-card">
                <h1>Select Control Mode</h1>
                <p class="text-gray-300 mb-6">How will you be playing today?</p>
                <button id="select-pc" class="menu-button primary-button">
                    PC / Keyboard & Mouse
                </button>
                <button id="select-mobile" class="menu-button secondary-button">
                    Mobile / Touchscreen
                </button>
            </div>
        </div>

        <!-- Main Menu Overlay -->
        <div id="main-menu-overlay" class="full-overlay" style="display: none;">
            <div class="menu-card">
                <h1>Block Sandbox World</h1>
                <p id="mode-confirmation" class="text-gray-300 mb-6"></p>
                <button id="play-button" class="menu-button primary-button">
                    Start Exploring
                </button>
                <button id="instructions-button" class="menu-button secondary-button">
                    Controls
                </button>
            </div>
        </div>

        <!-- Instructions Overlay -->
        <div id="instructions-overlay" class="full-overlay" style="display: none;">
            <div id="instructions-content" class="menu-card">
                <h1 style="text-align: center;">Controls</h1>
                <div id="control-list"></div>
                <button id="back-to-menu-button" class="menu-button secondary-button mt-4">
                    Back to Main Menu
                </button>
            </div>
        </div>

        <!-- Mobile Controls Overlay (Hidden by default, shown when isMobile is true) -->
        <div id="mobile-controls" style="display: none; position: fixed; bottom: 0; left: 0; width: 100%; height: 100%; z-index: 1000; pointer-events: none;">
            
            <!-- Virtual Joystick (Left) -->
            <div id="joystick-container">
                <div id="joystick-handle"></div>
            </div>
            
            <!-- Action/Jump Buttons (Right) -->
            <div class="fixed bottom-4 right-4 flex flex-col items-center space-y-4" style="pointer-events: auto;">
                <div id="jump-button-mobile" class="action-button-large" data-key="space" style="pointer-events: auto;">JUMP</div>
                <div id="respawn-button-mobile" class="action-button-small" data-key="e" style="pointer-events: auto;">RESPAWN (E)</div>
            </div>
            
            <!-- Touch Look Area (Full screen width for mobile, pointer-events: none initially) -->
            <div id="touch-look-area" class="fixed top-0 left-0 w-full h-full" style="pointer-events: auto;"></div>
        </div>


        <!-- Game UI Elements -->
        <!-- Death/Status Message Box -->
        <div id="message-box" class="message-box ui-box" style="display: none;">
            <span>VOIDED! Press E or use the RESPAWN button.</span>
        </div>
        
        <!-- Return to Menu Button (Fixed Position) -->
        <button id="return-to-menu-button" 
            class="fixed bottom-5 left-5 px-6 py-3 bg-indigo-600 text-white font-bold rounded-xl 
                   shadow-lg hover:bg-indigo-700 transition-all z-50"
            style="display: none;">
            Press L to Return to Menu
        </button>

    </div>

    <script>
        // --- Global Variables & Constants ---
        let scene, camera, renderer, world;
        let playerMesh, playerBody, startPosition;
        let playerMaterial, groundMaterial;

        const TIME_STEP = 1 / 60;
        const MOVEMENT_SPEED = 16;
        const JUMP_VELOCITY = 18;
        const CAMERA_DISTANCE = 15;
        const CAMERA_HEIGHT = 5;
        const MOUSE_SENSITIVITY = 0.0015; 
        const TOUCH_SENSITIVITY = 0.004;

        const keys = { w: false, a: false, s: false, d: false, space: false, e: false, l: false }; 
        let isPointerLocked = false;
        let playerYaw = 0;
        let isDead = false;
        let isGamePaused = true; 
        let isMobile = false; // Set by user selection

        // Joystick variables
        let joystickCenter = { x: 0, y: 0 };
        const JOYSTICK_RADIUS = 60; // Half of the container size (120px)
        let joystickTouchIdentifier = null; // CRITICAL: Tracks the finger dedicated to the joystick
        let lookTouchIdentifier = null; // CRITICAL: Tracks the finger dedicated to camera look
        let lastTouchX = 0;
        let lastTouchY = 0;

        // Block/Capsule dimensions
        const playerDimensions = { radius: 1, height: 2 }; 
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        
        // --- Tone.js Sound Variables & Functions ---
        let synth;
        let jumpSynth;
        let isAudioReady = false;

        async function initAudio() {
            if (isAudioReady) return; 
            try {
                // Ensure Tone is started before creating synths
                await Tone.start();
                
                synth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.3 }
                }).toDestination();

                jumpSynth = new Tone.PluckSynth({
                    attackNoise: 1, dampening: 2000, resonance: 0.7,
                }).toDestination();
                
                isAudioReady = true;
            } catch (e) {
                console.error("Audio initialization failed:", e);
            }
        }

        function playJumpSound() {
            if (!isAudioReady) return;
            jumpSynth.triggerAttackRelease("C5", "8n"); 
        }

        function playRespawnSound() {
            if (!isAudioReady) return;
            synth.triggerAttackRelease("G4", "16n", Tone.now() + 0.005);
        }
        
        function playDeathSound() {
            if (!isAudioReady) return;
            synth.triggerAttackRelease("C3", "8n", Tone.now());
            synth.triggerAttackRelease("B2", "8n", Tone.now() + 0.1);
            synth.triggerAttackRelease("A#2", "8n", Tone.now() + 0.2);
        }

        function hexToColor(hex) {
            return parseInt(hex.replace('#', '0x'), 16);
        }

        function showMessage(message) {
            const box = document.getElementById('message-box');
            box.querySelector('span').textContent = message;
            box.style.display = 'block';
        }

        // --- Menu Logic & Initialization ---
        
        function setupMenuListeners() {
            // Device Selection
            document.getElementById('select-pc').addEventListener('click', () => setDeviceMode(false));
            document.getElementById('select-mobile').addEventListener('click', () => setDeviceMode(true));

            // Main Menu
            document.getElementById('play-button').addEventListener('click', startGame);
            document.getElementById('instructions-button').addEventListener('click', showInstructions);
            document.getElementById('back-to-menu-button').addEventListener('click', showMainMenu);
        }
        
        function setDeviceMode(isMobileMode) {
            isMobile = isMobileMode;
            document.getElementById('device-select-overlay').style.display = 'none';
            document.getElementById('main-menu-overlay').style.display = 'flex';
            
            const confirmationText = isMobile 
                ? "Mobile controls selected: Joystick + Touch Look."
                : "PC controls selected: WASD + Mouse Look.";
            document.getElementById('mode-confirmation').textContent = confirmationText;

            // Show/hide mobile controls wrapper
            document.getElementById('mobile-controls').style.display = isMobile ? 'block' : 'none';

            // PC specific UI elements (return button and crosshair are only visible in game)
            if (!isMobile) {
                // If PC, show return button immediately in menu state, otherwise it's hidden.
                document.getElementById('return-to-menu-button').style.display = 'block';
            } else {
                 document.getElementById('return-to-menu-button').style.display = 'none';
            }

            if (isMobile) {
                // Set up mobile controls immediately upon selection
                setupJoystickControls();
                setupMobileButtonControls();
                setupTouchLook(); // CRITICAL: ensure touch look is set up
            }
        }

        function startGame() {
            document.getElementById('main-menu-overlay').style.display = 'none';
            document.getElementById('instructions-overlay').style.display = 'none';
            isGamePaused = false;
            
            if (!isMobile) {
                // PC: Attempt to lock the pointer
                renderer.domElement.requestPointerLock();
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('return-to-menu-button').style.display = 'block';
            } else {
                document.getElementById('return-to-menu-button').style.display = 'none';
                // CRITICAL: Update center when starting the game
                updateJoystickCenter(); 
            }
            
            initAudio();
        }

        function showInstructions() {
            document.getElementById('main-menu-overlay').style.display = 'none';
            document.getElementById('instructions-overlay').style.display = 'flex';
            updateInstructionsContent();
        }

        function updateInstructionsContent() {
            const container = document.getElementById('control-list');
            let content = '';

            if (isMobile) {
                content = `
                    <h2>Mobile Controls (Touch/Gesture)</h2>
                    <ul>
                        <li><strong>Virtual Joystick (Bottom-Left):</strong> Controls movement (Forward/Back/Strafe)</li>
                        <li><strong>Anywhere Else Drag:</strong> Look Around (Drag finger across the screen)</li>
                        <li><strong>JUMP Button:</strong> Jump</li>
                        <li><strong>RESPAWN Button:</strong> Respawn at center (if you fall off)</li>
                        <li><strong>Press L Key (optional):</strong> Return to Main Menu</li>
                    </ul>
                `;
            } else {
                content = `
                    <h2>Movement Controls (PC)</h2>
                    <ul>
                        <li><strong>W, A, S, D</strong>: Movement (Forward/Back/Strafe)</li>
                        <li><strong>Spacebar</strong>: Jump</li>
                        <li><strong>Mouse Movement</strong>: Look Around (Click the screen to start)</li>
                    </ul>

                    <h2>Game Actions (PC)</h2>
                    <ul>
                        <li><strong>E</strong>: Respawn at center (if you fall off)</li>
                        <li><strong>L</strong>: Return to Main Menu</li>
                    </ul>
                `;
            }
            container.innerHTML = content;
        }

        function showMainMenu() {
            // Hide all game-related UI elements
            document.getElementById('instructions-overlay').style.display = 'none';
            document.getElementById('message-box').style.display = 'none';
            document.getElementById('return-to-menu-button').style.display = 'none'; 
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'none'; 

            // Show the device selection menu again
            document.getElementById('device-select-overlay').style.display = 'flex';
            document.getElementById('main-menu-overlay').style.display = 'none';

            isGamePaused = true;
            isDead = false; 
            
            // CRITICAL: Reset mobile controls state
            keys.w = keys.a = keys.s = keys.d = false;
            joystickTouchIdentifier = null;
            lookTouchIdentifier = null;

            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }


        // --- Three.js & Cannon.js Initialization ---

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(hexToColor('#7cb9e8'));

            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Hide loading overlay
            document.getElementById('loading-overlay').style.display = 'none';
            
            // Show device selection overlay
            document.getElementById('device-select-overlay').style.display = 'flex';

            // Add basic light
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);

            // Initialize Cannon.js world
            world = new CANNON.World();
            world.gravity.set(0, -40, 0); // Increased gravity for snappier falls
            world.broadphase = new CANNON.SAPBroadphase(world);

            // Setup Physics Materials
            playerMaterial = new CANNON.Material("playerMaterial");
            groundMaterial = new CANNON.Material("groundMaterial");
            const groundPlayerContact = new CANNON.ContactMaterial(groundMaterial, playerMaterial, {
                friction: 0.1,
                restitution: 0.0 // No bounce
            });
            world.addContactMaterial(groundPlayerContact);

            // Create Ground (The platform)
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to lay flat
            world.addBody(groundBody);
            
            // Create Ground Mesh (Three.js)
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMesh = new THREE.Mesh(groundGeometry, new THREE.MeshPhongMaterial({ color: hexToColor('#10b981') }));
            groundMesh.rotation.x = -Math.PI / 2;
            scene.add(groundMesh);

            // Create Player (Capsule for better collision)
            const playerShape = new CANNON.Cylinder(playerDimensions.radius, playerDimensions.radius, playerDimensions.height, 8);
            playerBody = new CANNON.Body({ mass: 10, material: playerMaterial, fixedRotation: true });
            // Offset the cylinder shape to align with the body's center
            playerBody.addShape(playerShape, new CANNON.Vec3(0, 0, 0));
            
            // Set start position and add to world
            startPosition = new CANNON.Vec3(0, 10, 0);
            playerBody.position.copy(startPosition);
            world.addBody(playerBody);

            // Create Player Mesh (Three.js)
            const playerGeometry = new THREE.CylinderGeometry(playerDimensions.radius, playerDimensions.radius, playerDimensions.height, 8);
            playerMesh = new THREE.Mesh(playerGeometry, new THREE.MeshPhongMaterial({ color: hexToColor('#facc15') }));
            scene.add(playerMesh);

            // Setup Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            setupMenuListeners();
            setupPointerLock(); // Mouse look setup

            // CRITICAL FIX: Ensure joystick center is calculated on load and resize
            window.addEventListener('load', updateJoystickCenter);
            window.addEventListener('resize', updateJoystickCenter);
        }
        
        // --- Joystick Logic (CRITICALLY FIXED) ---

        function updateJoystickCenter() {
            const joystickArea = document.getElementById('joystick-container');
            if (joystickArea) {
                const rect = joystickArea.getBoundingClientRect();
                // Center point calculation
                joystickCenter.x = rect.left + JOYSTICK_RADIUS;
                joystickCenter.y = rect.top + JOYSTICK_RADIUS;
            }
        }
        
        function moveJoystickHandle(dx, dy) {
            const joystickHandle = document.getElementById('joystick-handle');
            // Apply translation to the handle element (Centered: -half-width offset)
            const knobOffsetX = dx;
            const knobOffsetY = dy;
            
            // Use translation relative to the center of the container
            joystickHandle.style.transform = `translate(calc(-50% + ${knobOffsetX}px), calc(-50% + ${knobOffsetY}px))`;
            
            // Normalize the vector (0 to 1) and map to WASD keys
            const normalizedX = dx / JOYSTICK_RADIUS;
            const normalizedY = dy / JOYSTICK_RADIUS;

            // Update keys for player movement:
            // Forward/Backward (W/S) is negative Y screen coordinate (up on screen is -Y)
            keys.w = normalizedY < -0.1;
            keys.s = normalizedY > 0.1;
            
            // Strafe (A/D) is X screen coordinate (right on screen is +X)
            keys.a = normalizedX < -0.1;
            keys.d = normalizedX > 0.1;
        }

        function resetJoystickHandle() {
            joystickTouchIdentifier = null;
            keys.w = keys.a = keys.s = keys.d = false;
            moveJoystickHandle(0, 0); // Move handle back to center
        }

        function setupJoystickControls() {
            const joystickArea = document.getElementById('joystick-container');
            
            joystickArea.addEventListener('touchstart', (e) => {
                e.preventDefault(); // FIX: Prevent default scrolling/zooming immediately
                if (joystickTouchIdentifier !== null) return; // Ignore if another touch is already controlling the joystick
                
                // Use the first new touch found
                const touch = e.changedTouches[0];
                joystickTouchIdentifier = touch.identifier;
                
                // Recalculate center on touch start for precision
                updateJoystickCenter(); 
                
                // Move the handle based on touch position relative to center
                moveJoystickHandle(touch.clientX - joystickCenter.x, touch.clientY - joystickCenter.y);
            }, { passive: false }); // FIX: Must be passive: false

            joystickArea.addEventListener('touchmove', (e) => {
                e.preventDefault(); // FIX: Prevent default scrolling during drag
                if (joystickTouchIdentifier === null) return;

                // Find the touch corresponding to the joystick ID
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === joystickTouchIdentifier) {
                        
                        let dx = touch.clientX - joystickCenter.x;
                        let dy = touch.clientY - joystickCenter.y;

                        // Clamp distance
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > JOYSTICK_RADIUS) {
                            const angle = Math.atan2(dy, dx);
                            dx = JOYSTICK_RADIUS * Math.cos(angle);
                            dy = JOYSTICK_RADIUS * Math.sin(angle);
                        }
                        
                        moveJoystickHandle(dx, dy);
                        break;
                    }
                }
            }, { passive: false }); // FIX: Must be passive: false

            // Universal touchend/touchcancel handler for the joystick area
            const handleJoystickEnd = (e) => {
                // Check if the releasing finger is the one controlling the joystick
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchIdentifier) {
                        resetJoystickHandle();
                        break;
                    }
                }
            };
            joystickArea.addEventListener('touchend', handleJoystickEnd, { passive: false });
            joystickArea.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
        }


        // --- Mobile Button Controls (Fixed) ---

        function setupMobileButtonControls() {
            const jumpButton = document.getElementById('jump-button-mobile');
            const respawnButton = document.getElementById('respawn-button-mobile');
            
            // Generic handler for buttons
            const handleTouchStart = (e) => {
                e.preventDefault(); // FIX: CRITICAL - Stop browser interference
                const key = e.currentTarget.dataset.key;
                keys[key] = true;
                e.currentTarget.classList.add('active');
            };

            const handleTouchEnd = (e) => {
                e.preventDefault(); // FIX: CRITICAL - Stop browser interference
                const key = e.currentTarget.dataset.key;
                
                // The jump check (keys.space) is handled in the game loop. 
                keys[key] = false;
                e.currentTarget.classList.remove('active');
                
                // Special case for 'E' (Respawn) - trigger immediately on release
                if (key === 'e') {
                    respawnPlayer();
                }
            };

            // JUMP BUTTON
            jumpButton.addEventListener('touchstart', handleTouchStart, { passive: false });
            jumpButton.addEventListener('touchend', handleTouchEnd, { passive: false });
            jumpButton.addEventListener('touchcancel', handleTouchEnd, { passive: false });
            
            // RESPAWN BUTTON
            respawnButton.addEventListener('touchstart', handleTouchStart, { passive: false });
            respawnButton.addEventListener('touchend', handleTouchEnd, { passive: false });
            respawnButton.addEventListener('touchcancel', handleTouchEnd, { passive: false });
        }


        // --- Touch Look (CRITICALLY FIXED) ---

        function setupTouchLook() {
            const lookArea = document.getElementById('touch-look-area');

            lookArea.addEventListener('touchstart', (e) => {
                // Check if the target is *not* one of the buttons or the joystick
                if (lookTouchIdentifier !== null) return; 
                
                // Find a touch that is not the joystick touch and is initiating the look
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    // Only start looking if this touch hasn't been claimed by the joystick
                    if (touch.identifier !== joystickTouchIdentifier) {
                         // We don't use preventDefault here to allow other touches to interact with UI,
                         // but we rely on the specific target element filtering in the other handlers.
                        lookTouchIdentifier = touch.identifier;
                        lastTouchX = touch.clientX;
                        lastTouchY = touch.clientY;
                        break; 
                    }
                }
            }, { passive: true });

            lookArea.addEventListener('touchmove', (e) => {
                if (lookTouchIdentifier === null) return;

                let currentTouch = null;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === lookTouchIdentifier) {
                        currentTouch = e.changedTouches[i];
                        break;
                    }
                }

                if (currentTouch) {
                    // Calculate delta movement
                    const movementX = currentTouch.clientX - lastTouchX;
                    
                    // Apply rotation logic
                    playerYaw -= movementX * TOUCH_SENSITIVITY;
                    
                    // Update last position
                    lastTouchX = currentTouch.clientX;
                    lastTouchY = currentTouch.clientY;
                }
            }, { passive: true }); // passive: true for performance during continuous looking

            const handleLookEnd = (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === lookTouchIdentifier) {
                        lookTouchIdentifier = null;
                        break;
                    }
                }
            };
            lookArea.addEventListener('touchend', handleLookEnd, { passive: true });
            lookArea.addEventListener('touchcancel', handleLookEnd, { passive: true });
        }
        
        // --- End of CRITICAL Mobile Fixes ---


        // --- Other Game Functions (Unchanged) ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function canJump() {
            // Checks if the player is standing on the ground using a raycast
            raycaster.set(playerMesh.position, downVector);
            raycaster.far = playerDimensions.height / 2 + 0.5; // Ray extends slightly below the body
            
            const intersections = raycaster.intersectObjects(scene.children, true);
            
            // Filter out the player's own mesh
            const groundIntersections = intersections.filter(i => i.object !== playerMesh);

            return groundIntersections.length > 0;
        }

        function onKeyDown(event) {
            if (isGamePaused) return;

            // Map standard keys
            if (event.key === 'w') keys.w = true;
            if (event.key === 'a') keys.a = true;
            if (event.key === 's') keys.s = true;
            if (event.key === 'd') keys.d = true;
            if (event.key === ' ') keys.space = true;
            if (event.key === 'e') keys.e = true;
            if (event.key === 'l') keys.l = true; // Return to menu

            if (keys.l) {
                showMainMenu();
            }

            if (keys.e && isDead) {
                respawnPlayer();
            }

            if (keys.space && canJump()) {
                playerBody.velocity.y = JUMP_VELOCITY;
                playJumpSound();
            }
        }

        function onKeyUp(event) {
            if (isGamePaused) return;

            if (event.key === 'w') keys.w = false;
            if (event.key === 'a') keys.a = false;
            if (event.key === 's') keys.s = false;
            if (event.key === 'd') keys.d = false;
            if (event.key === ' ') keys.space = false;
            if (event.key === 'e') keys.e = false;
        }

        function setupPointerLock() {
            const element = renderer.domElement;
            
            // PC: Lock pointer on click
            element.addEventListener('click', () => {
                if (!isMobile && !isGamePaused) {
                    element.requestPointerLock();
                }
            });

            // Handle lock/unlock events
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = (document.pointerLockElement === element);
                if (isPointerLocked) {
                    document.getElementById('crosshair').style.display = 'block';
                    document.addEventListener('mousemove', onMouseMove, false);
                } else {
                    // Pointer unlocked (e.g., user pressed Esc)
                    document.getElementById('crosshair').style.display = 'none';
                    document.removeEventListener('mousemove', onMouseMove, false);
                    if (!isGamePaused) {
                        showMessage("Game Paused. Click to resume.");
                    }
                }
            }, false);
        }

        function onMouseMove(event) {
            if (!isGamePaused && isPointerLocked) {
                playerYaw -= event.movementX * MOUSE_SENSITIVITY;
            }
        }

        function respawnPlayer() {
            if (!isDead) { 
                // Allow respawn via 'E' only when dead, but still play sound if forced
                playRespawnSound(); 
                return;
            }
            
            // Reset player physics state
            playerBody.velocity.set(0, 0, 0);
            playerBody.angularVelocity.set(0, 0, 0);
            playerBody.position.copy(startPosition);

            playerBody.wakeUp(); // Ensure body is active
            
            // Reset game state
            isDead = false;
            document.getElementById('message-box').style.display = 'none';
            playerMesh.material.color.set(hexToColor('#facc15'));
            playRespawnSound();
        }


        // --- Game Loop ---

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            if (isGamePaused) {
                // If paused, just render the scene statically
                renderer.render(scene, camera); 
                return;
            }

            const delta = clock.getDelta();

            // 1. Physics Step
            world.step(TIME_STEP, delta);
            
            // 2. Player Movement and Rotation
            if (!isDead) {
                // Determine movement direction based on current yaw (rotation)
                const forwardVector = new THREE.Vector3(0, 0, -1);
                forwardVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), playerYaw);
                
                const rightVector = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forwardVector);

                // Preserve Y velocity for jumping/falling
                const currentVelocityY = playerBody.velocity.y;
                let desiredVelocity = new CANNON.Vec3(0, 0, 0);

                if (keys.w) { desiredVelocity.vadd(new CANNON.Vec3(forwardVector.x, 0, forwardVector.z).scale(MOVEMENT_SPEED), desiredVelocity); }
                if (keys.s) { desiredVelocity.vadd(new CANNON.Vec3(forwardVector.x, 0, forwardVector.z).scale(-MOVEMENT_SPEED), desiredVelocity); }
                if (keys.a) { desiredVelocity.vadd(new CANNON.Vec3(rightVector.x, 0, rightVector.z).scale(-MOVEMENT_SPEED), desiredVelocity); }
                if (keys.d) { desiredVelocity.vadd(new CANNON.Vec3(rightVector.x, 0, rightVector.z).scale(MOVEMENT_SPEED), desiredVelocity); }

                // Apply new XZ velocity while maintaining gravity's effect (Y velocity)
                playerBody.velocity.set(desiredVelocity.x, currentVelocityY, desiredVelocity.z);

                // Update Three.js mesh position and rotation
                playerMesh.position.copy(playerBody.position);
                playerMesh.quaternion.copy(playerBody.quaternion);
            }


            // 3. Camera Update (Third Person View)
            
            // Calculate camera direction vector based on playerYaw
            const camDir = new THREE.Vector3(0, 0, 1); // Start facing back
            camDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), playerYaw);
            camDir.normalize();

            // Calculate target position for the camera
            const playerPos = playerMesh.position;
            const targetX = playerPos.x + camDir.x * CAMERA_DISTANCE;
            const targetY = playerPos.y + CAMERA_HEIGHT;
            const targetZ = playerPos.z + camDir.z * CAMERA_DISTANCE;

            camera.position.set(targetX, targetY, targetZ);
            camera.lookAt(playerPos.x, playerPos.y + playerDimensions.height / 2, playerPos.z);
            

            // 4. Death Condition
            if (playerBody.position.y < -30 && !isDead) {
                isDead = true;
                playerBody.sleep(); // Stop physics when dead
                playerMesh.material.color.set(hexToColor('#b91c1c')); // Turn red
                showMessage("VOIDED! Press E or use the RESPAWN button.");
                playDeathSound();
            }

            // 5. Render
            renderer.render(scene, camera);
        }

        // Initialize the game
        window.onload = function () {
            init();
            animate();
        }
    </script>
</body>
</html>